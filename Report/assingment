🧩 문제 1

Q. 비트 AND(&) 연산의 결과가 1이 되려면 어떤 조건이 필요한가?

✅ 풀이:
비트 AND는 두 비트가 모두 1일 때만 결과가 1이 된다.
예: 1 & 1 = 1, 1 & 0 = 0, 0 & 1 = 0, 0 & 0 = 0

✅ 정답:
→ 두 비트가 모두 1일 때 결과가 1이다.

🧩 문제 2

Q. 8 | 4 의 결과는? (비트 OR 연산)

✅ 풀이:
8 = 1000
4 = 0100
OR = 1100 → 10진수로 12

✅ 정답:
→ 12

🧩 문제 3

Q. 8 & 4 의 결과는?

✅ 풀이:
8 = 1000
4 = 0100
AND = 0000 → 0

✅ 정답:
→ 0

🧩 문제 4

Q. 8 ^ 4 (XOR 연산)의 결과는?

✅ 풀이:
8 = 1000
4 = 0100
XOR = 1100 → 12

✅ 정답:
→ 12

🧩 문제 5

Q. ~5 의 결과는?

✅ 풀이:
~는 비트 반전 (1→0, 0→1)
5 = 0000 0101 → 반전 = 1111 1010
즉, 2의 보수 표현으로 -6

✅ 정답:
→ -6

🧩 문제 6

Q. 5 << 1 의 결과는?

✅ 풀이:
왼쪽 시프트는 1비트 이동 → 2배
즉, 5 * 2 = 10

✅ 정답:
→ 10

🧩 문제 7

Q. 8 >> 2 의 결과는?

✅ 풀이:
오른쪽 시프트는 2비트 이동 → 8 / 4 = 2

✅ 정답:
→ 2

🧩 문제 8

Q. 3 << 3 의 결과는?

✅ 풀이:
왼쪽 시프트 3비트 → 3 * 2³ = 3 * 8 = 24

✅ 정답:
→ 24

🧩 문제 9

Q. 12 >> 2 의 결과는?

✅ 풀이:
12 / 4 = 3

✅ 정답:
→ 3

🧩 문제 10

Q. 다음 중 2의 거듭제곱인지 판별하는 방법은?
(힌트: (n & (n-1)) == 0)

✅ 풀이:
2의 거듭제곱 수는 이진수에서 딱 하나의 1만 있음
예: 8(1000), 16(10000)
→ n & (n-1) 하면 0이 된다.

✅ 정답:
→ (n & (n-1)) == 0 일 때 2의 거듭제곱이다.

🧩 문제 11

Q. 플래그 비트 0x04가 켜져 있는지 확인하려면?

✅ 풀이:
if (value & 0x04) != 0

✅ 정답:
→ (value & 0x04) != 0

🧩 문제 12

Q. 플래그 0x02를 켜는 연산은?

✅ 풀이:
OR 연산으로 설정
value |= 0x02

✅ 정답:
→ value |= 0x02

🧩 문제 13

Q. 플래그 0x02를 끄는 연산은?

✅ 풀이:
AND와 NOT 조합
value &= ~0x02

✅ 정답:
→ value &= ~0x02

🧩 문제 14

Q. 비트 토글 (0→1, 1→0) 하는 연산은?

✅ 풀이:
XOR 사용
value ^= mask

✅ 정답:
→ value ^= mask

🧩 문제 15

Q. 특정 비트가 1인지 0인지 확인하는 방법?

✅ 풀이:
AND 연산 후 비교
if ((value & mask) != 0) → 1
else → 0

✅ 정답:
→ (value & mask) != 0

🧩 문제 16

Q. 음수의 비트 표현은 어떤 방식인가?

✅ 풀이:
2의 보수 (Two’s Complement)
→ 양수의 비트 반전 후 +1

✅ 정답:
→ 2의 보수 표현

🧩 문제 17

Q. 1바이트(8비트)에서 최댓값과 최솟값은?

✅ 풀이:

부호 없는 경우: 0~255

부호 있는 경우: -128~127

✅ 정답:
→ unsigned: 0~255 / signed: -128~127

🧩 문제 18

Q. a & 1 의 의미는?

✅ 풀이:
a의 홀짝 판별 (마지막 비트가 1이면 홀수)

✅ 정답:
→ a가 홀수인지 확인

🧩 문제 19

Q. a & (1 << n) 의 의미는?

✅ 풀이:
a의 n번째 비트가 켜져 있는지 확인

✅ 정답:
→ n번째 비트가 1인지 판별

1.
mov bx, 0FFFFh
and  bx, 6Bh


0FFFFh & 006Bh = 006Bh
BX = 006Bh

2.
mov bx, 91BAh
and  bx, 92h


하이바이트 91h & 00h = 00h, 로우바이트 BAh & 92h = 92h →
BX = 0092h

3.
mov bx, 0649Bh
or   bx, 3Ah


로우바이트: 9Bh | 3Ah = BBh →
BX = 64BBh

4.
mov bx, 029D6h
xor  bx, 8181h


바이트별 XOR: 29h ^ 81h = A8h, D6h ^ 81h = 57h →
BX = A857h

5.
mov ebx, 0AFAF649Bh
or   ebx, 3A219604h


(32비트로 보면 초기값은 AFAF649Bh)
바이트별 OR 결과 → EBX = BFAFF69Fh

6.
mov rbx, 0AFAF649Bh
xor  rbx, 0FFFFFFFFh


(초기값이 32비트 범위 AFAF649Bh로 보고, 0xFFFFFFFF는 저하위 32비트를 flip 함)
하위 32비트: FFFFFFFFh ^ AFAF649Bh = 50509B64h
상위 32비트는 0 →
RBX = 00000000 50509B64h (간단히 50509B64h)

7. (각 결과를 2진수로)
a)
mov al, 01101111b    ; 6Fh
and al, 00101101b    ; 2Dh
→ 01101111 & 00101101 = 00101101
**AL = 00101101b** (2Dh)

b)
mov al, 6Dh           ; 6Dh = 01101101b
and al, 4Ah           ; 4Ah = 01001010b
→ 01101101 & 01001010 = 01001000
**AL = 01001000b** (48h)

c)
mov al, 00001111b     ; 0Fh
or  al, 61h           ; 61h = 01100001b
→ 00001111 | 01100001 = 01101111
**AL = 01101111b** (6Fh)

d)
mov al, 94h           ; 94h = 10010100b
xor al, 37h           ; 37h = 00110111b
→ 10010100 ^ 00110111 = 10100011
**AL = 10100011b** (A3h)

8. (각 결과를 16진수로)
a)
mov al, 7Ah
not al
→ ~7Ah = 85h
**AL = 85h**

b)
mov al, 3Dh
and al, 74h
→ 3Dh & 74h = 34h
**AL = 34h**

c)
mov al, 9Bh
or  al, 35h
→ 9Bh | 35h = BFh
**AL = BFh**

d)
mov al, 72h
xor al, 0DCh
→ 72h ^ DCh = AEh
**AL = AEh**

9. (Carry, Zero, Sign 플래그)

참고: TEST는 CF, OF를 0으로 만들고 SF/ZF/PF는 결과에 따라 설정.
CMP는 빼기(subtract) 결과의 플래그를 설정(부호·영·캐리 등).

a)
mov al, 00001111b    ; 0Fh
test al, 00000010b   ; 02h
→ 0Fh & 02h = 02h (0이 아님)
CF = 0   ZF = 0   SF = 0

b)
mov al, 00000110b    ; 06h
cmp al, 00000101b    ; 05h → 06 - 05 = +1
→ 양수
CF = 0   ZF = 0   SF = 0

c)
mov al, 00000101b    ; 05h
cmp al, 00000111b    ; 07h → 05 - 07 = -2
→ 음수, 언더플로(비교에서 빌림)
CF = 1   ZF = 0   SF = 1

10.

질문: ECX의 값에 따라 분기하는 조건문은?
정답: JECXZ (32비트 환경에서 ECX가 0이면 분기. 16비트면 JCXZ)

11.

질문: JA와 JNBE는 Zero와 Carry 플래그에 어떻게 영향을 받나?
정답: 둘은 동치이며 CF = 0 이고 ZF = 0 일 때 분기한다.
(즉 unsigned 비교에서 “위(above)” — 엄격한 초과)

12.
mov edx,1
mov eax,7FFFh
cmp eax,8000h
jl  L1
mov edx,0
L1:


7FFFh(32767) 과 8000h(-32768, signed) 비교 → signed에서 32767 < -32768? 아니다 → jl 불발, mov edx,0 실행.
최종 EDX = 0

13.
mov edx,1
mov eax,7FFFh
cmp eax,8000h
jb  L1
mov edx,0
L1:


jb는 unsigned 비교: 32767 < 32768 → 참 → 분기 실행(L1)하고 mov edx,0을 건너뜀.
최종 EDX = 1

14.
mov edx,1
mov eax,7FFFh
cmp eax,0FFFF8000h
jl L2
mov edx,0
L2:


0FFFF8000h (32비트)은 signed로 보면 FFFF8000h = -32768. 비교: 32767 < -32768? (signed) 아니다 → jl 불발 → mov edx,0 실행.
최종 EDX = 0

15. (참/거짓)
mov eax, -30
cmp eax, -50
jg Target


-30 > -50 → 참 → jg 분기 실행
정답: True

16. (참/거짓)
mov eax, -42
cmp eax, 26
ja Target


ja는 unsigned above. -42를 unsigned로 보면 큰 값(0xFFFFFFD6)이라 > 26 → ja 분기 실행
정답: True

17.
mov rbx, 0FFFFFFFFFFFFFFFFh
and rbx, 80h


모두 1인 값과 0x80 AND → 0x80
RBX = 00000000...00000080h (간단히 80h)

18.
mov rbx, 0FFFFFFFFFFFFFFFFh
and rbx, 808080h


808080h = 00 80 80 80 (3바이트) → 결과 그대로 00808080h
RBX = 00808080h

19.
mov rbx, 0FFFFFFFFFFFFFFFFh
and rbx, 80808080h


결과 = 80808080h
RBX = 80808080h
