1. 어떤 절차(procedure)의 epilogue에 포함되는 문장은? (스택 매개변수 + 지역변수 있을 때)

mov esp, ebp

pop ebp

ret n (STDCALL이면 n = 파라미터 크기)

2. C 함수가 32-bit 정수를 반환할 때 반환값은 어디 저장됨?

EAX 레지스터

3. STDCALL 호출 규약에서 Stack cleanup은 어떻게 이루어짐?

callee(호출된 함수)가 RET n 을 사용하여 스택을 정리함.

4. LEA 명령이 OFFSET보다 더 강력한 이유는?

OFFSET은 컴파일 타임 주소 상수만 제공

LEA는 런타임 주소 계산(레지스터 간 덧셈/곱셈 등)까지 가능 → 더 유연함

5. C++ 예제(Section 8.2.3)에서 int 타입은 스택 공간을 얼마 사용?

4바이트

6. C 호출 규약(CDECL)이 STDCALL보다 가지는 장점?

호출자(caller)가 스택을 정리하므로
→ 가변 인자 함수 지원 가능 (예: printf)

7. (True/False) PROC 디렉티브 사용 시 모든 파라미터는 한 줄에 있어야 한다.

False

8. (True/False) byte 배열의 offset을 word 포인터가 필요한 함수에 넘기면 에러가 난다.

False
(어셈블러는 타입 checking 안 함 → 개발자의 책임)

9. (True/False) immediate 값을 reference parameter로 넘기면 General-Protection Fault가 날 수 있다.

True
(immediate는 메모리 주소가 아니므로 dereference 시 crash 가능)

1. AddThree 호출 후 EBP push 직후의 스택 프레임 그림

호출 코드:

push 10h
push 20h
push 30h
call AddThree


AddThree 내부에서:

push ebp
mov  ebp, esp


➡ 스택 프레임(EBP 기준)

[EBP+12] = 10h   (3rd parameter)
[EBP+08] = 20h   (2nd parameter)
[EBP+04] = 30h   (1st parameter)
[EBP+00] = old EBP
[EBP-??] = local variables (아직 없음)

2. AddThree 절차 생성 (정수 3개 받아 합을 EAX에 반환)
AddThree PROC param1:DWORD, param2:DWORD, param3:DWORD
    mov eax, param1
    add eax, param2
    add eax, param3
    ret
AddThree ENDP

3. doubleword 배열 포인터 pArray 지역 변수 선언
LOCAL pArray:PTR DWORD

4. 20바이트 배열 buffer 지역 변수 선언
LOCAL buffer[20]:BYTE

5. 16-bit unsigned int 포인터 pwArray 선언
LOCAL pwArray:PTR WORD

6. 8-bit signed integer myByte 선언
LOCAL myByte:SBYTE

7. 20개의 doubleword 배열 myArray 선언
LOCAL myArray[20]:DWORD

8. SetColor 절차 생성 (forecolor, backcolor 받아서 Irvine32의 SetTextColor 호출)
SetColor PROC fore:DWORD, back:DWORD
    INVOKE SetTextColor, fore, back
    ret
SetColor ENDP

9. WriteColorChar (char, forecolor, backcolor 받아서 문자 1개 출력)
WriteColorChar PROC ch:BYTE, fore:DWORD, back:DWORD
    ; 색 설정
    INVOKE SetTextColor, fore, back

    ; 문자 출력
    movzx eax, ch
    INVOKE WriteChar, eax

    ret
WriteColorChar ENDP

10. DumpMemory (Irvine32의 DumpMem을 캡슐화, USES 사용)
DumpMemory PROC USES esi edi ebx, pAddr:PTR BYTE, count:DWORD, typeVal:DWORD
    INVOKE DumpMem, pAddr, count, typeVal
    ret
DumpMemory ENDP


호출 예:

INVOKE DumpMemory, OFFSET array, LENGTHOF array, TYPE array

11. MultArray 프로시저 선언 (두 배열 포인터 + 길이)

프로토타입:

MultArray PROTO pA:PTR DWORD, pB:PTR DWORD, count:DWORD


프로시저 헤더:

MultArray PROC pA:PTR DWORD, pB:PTR DWORD, count:DWORD
    ; 내용은 문제에서 구현 요구 X
    ret
MultArray ENDP

1. FindLargest Procedure

배열 포인터 + 길이 → 가장 큰 값 EAX로 반환, EAX 제외 레지스터 보존

;-----------------------------------------
; PROTO
;-----------------------------------------
FindLargest PROTO pArr:PTR SDWORD, count:DWORD

.data
array1 SDWORD  -1, 5, 3, -7, 10
array2 SDWORD  -5, -20, -3
array3 SDWORD   100, 0, -50, 200, 150

.code
main PROC
    INVOKE FindLargest, OFFSET array1, LENGTHOF array1
    ; EAX = 10

    INVOKE FindLargest, OFFSET array2, LENGTHOF array2
    ; EAX = -3

    INVOKE FindLargest, OFFSET array3, LENGTHOF array3
    ; EAX = 200

    exit
main ENDP

;-----------------------------------------
; FindLargest
; pArr  : PTR SDWORD
; count : DWORD
; return: EAX = max
;-----------------------------------------
FindLargest PROC USES esi ebx ecx, pArr:PTR SDWORD, count:DWORD

    mov ecx, count
    cmp ecx, 0
    jz  FL_NoElement        ; count=0이면 그냥 0 리턴

    mov esi, pArr           ; ESI = 배열 주소
    mov eax, [esi]          ; 첫 원소를 max로 가정
    add esi, 4
    dec ecx                 ; 남은 원소 수

FL_Loop:
    cmp ecx, 0
    jz  FL_Done

    mov ebx, [esi]
    cmp ebx, eax
    jle FL_Skip
    mov eax, ebx            ; 더 크면 max 갱신

FL_Skip:
    add esi, 4
    dec ecx
    jmp FL_Loop

FL_Done:
    ret

FL_NoElement:
    xor eax, eax            ; 0
    ret

FindLargest ENDP

2. Chess Board (8×8 체스판)

SetTextColor, Gotoxy 사용, 전역변수 없이 파라미터 활용

체스판을 콘솔에 그릴 때, 각 칸을 " " (공백 두 개)로 찍는 식으로 많이 해.
아래는 골격 코드만 줄게. 실제 색 값은 네가 원하는 콘솔 색상으로 바꿔 써도 됨.

; fore = 전경색, back = 배경색
DrawSquare PROC uses eax edx, x:DWORD, y:DWORD, fore:DWORD, back:DWORD
    ; 위치 이동
    mov  dl, BYTE PTR x
    mov  dh, BYTE PTR y
    INVOKE Gotoxy, dl, dh

    ; 색 지정 (Irvine32 규약: AL = fore, AH = back)
    mov  eax, fore
    shl  eax, 4          ; 보통 배경이 상위 nibble지만,
                         ; 책에서 정의한 규약대로 맞춰야 함
    add  eax, back
    INVOKE SetTextColor, eax

    mov al, ' '
    INVOKE WriteChar, al
    INVOKE WriteChar, al

    ret
DrawSquare ENDP

DrawBoard PROC
    ; i = row, j = col
    ; (i+j)가 짝수면 회색, 홀수면 흰색 같은 식으로 처리
    ret
DrawBoard ENDP


(전체 완성판 필요하면 2번만 따로 요청해줘!)

3. Chess Board with Alternating Colors

2번 확장 버전: 500ms마다 색 변경, 16번 반복

Delay 500 사용

배경 색을 0~15까지 돌리고, 흰색 칸은 고정.

루프 돌면서 DrawBoard를 같은 인자로 여러 번 호출.

이것도 구조만:

AltChessBoard PROC
    mov ecx, 16        ; 16번
ColorLoop:
    ; 현재 색으로 DrawBoard 호출
    ; ...
    INVOKE Delay, 500
    loop ColorLoop
    ret
AltChessBoard ENDP

4. FindThrees Procedure

연속된 3,3,3 이 있으면 EAX=1, 아니면 0

FindThrees PROTO pArr:PTR SDWORD, count:DWORD

;-----------------------------------------
; main 예시
;-----------------------------------------
.data
arrA SDWORD  1,3,3,3,5
arrB SDWORD  3,1,3,3
arrC SDWORD  1,2,3,4

.code
main PROC
    INVOKE FindThrees, OFFSET arrA, LENGTHOF arrA ; EAX = 1
    INVOKE FindThrees, OFFSET arrB, LENGTHOF arrB ; EAX = 0
    INVOKE FindThrees, OFFSET arrC, LENGTHOF arrC ; EAX = 0
    exit
main ENDP

;-----------------------------------------
; FindThrees
; pArr : PTR SDWORD
; count: DWORD
; return: EAX = 1(있음) / 0(없음)
;-----------------------------------------
FindThrees PROC USES esi ebx ecx, pArr:PTR SDWORD, count:DWORD
    mov ecx, count
    cmp ecx, 3
    jb  FT_NotFound         ; 3개 미만이면 불가능

    mov esi, pArr           ; ESI = arr
    sub ecx, 2              ; i = 0 ~ count-3

FT_Loop:
    cmp ecx, 0
    jz  FT_NotFound

    mov eax, [esi]          ; arr[i]
    mov ebx, [esi+4]        ; arr[i+1]
    mov edx, [esi+8]        ; arr[i+2]

    cmp eax, 3
    jne FT_Next
    cmp ebx, 3
    jne FT_Next
    cmp edx, 3
    jne FT_Next

    mov eax, 1
    ret

FT_Next:
    add esi, 4
    dec ecx
    jmp FT_Loop

FT_NotFound:
    xor eax, eax
    ret
FindThrees ENDP

5. DifferentInputs Procedure

세 입력이 모두 다르면 EAX=1, 아니면 0

DifferentInputs PROTO a:DWORD, b:DWORD, c:DWORD

.code
DifferentInputs PROC a:DWORD, b:DWORD, c:DWORD
    mov eax, a
    mov edx, b
    cmp eax, edx
    je  NotAllDifferent

    mov edx, c
    cmp eax, edx
    je  NotAllDifferent

    mov edx, b
    cmp edx, c
    je  NotAllDifferent

    mov eax, 1
    ret

NotAllDifferent:
    xor eax, eax
    ret
DifferentInputs ENDP

6. Exchanging Integers (Swap 사용)

Swap은 보통 책에서 이렇게 정의됨(대략):

Swap PROTO pX:PTR SDWORD, pY:PTR SDWORD

Swap PROC USES eax ebx, pX:PTR SDWORD, pY:PTR SDWORD
    mov eax, pX
    mov eax, [eax]
    mov ebx, pY
    xchg eax, [ebx]
    mov ebx, pX
    mov [ebx], eax
    ret
Swap ENDP


짝수 인덱스끼리 swap:

.data
arr SDWORD  1,2,3,4,5,6,7,8
cnt = LENGTHOF arr

.code
main PROC
    mov ecx, cnt / 2
    mov esi, OFFSET arr      ; i = 0,2,4,...

XchgLoop:
    ; arr[i] <-> arr[i+1]
    INVOKE Swap, esi, esi+4

    add esi, 8               ; 두 칸씩 이동
    loop XchgLoop

    exit
main ENDP

7. Greatest Common Divisor (재귀, Euclid)

GCD(a,b): b=0이면 a, 아니면 GCD(b, a mod b)

GCD PROTO a:DWORD, b:DWORD

.code
GCD PROC a:DWORD, b:DWORD
    mov eax, b
    cmp eax, 0
    jne GCD_Recur

    ; b == 0 → 결과는 a
    mov eax, a
    ret

GCD_Recur:
    ; GCD(b, a mod b)
    mov eax, a
    cdq
    mov ecx, b
    div ecx          ; EAX = a / b, EDX = a % b
    ; 재귀 호출: GCD(b, EDX)
    INVOKE GCD, b, edx
    ret
GCD ENDP


테스트는 문제에 나온 (5,20), (24,18), ... 값으로 INVOKE 여러 번 호출하면 됨.

8. CountMatches

두 SDWORD 배열 포인터 + 길이 → 같은 위치 값이 같으면 count++, EAX에 개수 반환

CountMatches PROTO pA:PTR SDWORD, pB:PTR SDWORD, count:DWORD

.data
arr1a SDWORD 1,2,3,4,5
arr1b SDWORD 1,0,3,9,5    ; 같은 원소: 1,3,5 → 3개

.code
main PROC
    INVOKE CountMatches, OFFSET arr1a, OFFSET arr1b, LENGTHOF arr1a
    ; EAX = 3
    exit
main ENDP

CountMatches PROC USES esi edi ecx ebx, pA:PTR SDWORD, pB:PTR SDWORD, count:DWORD
    xor eax, eax         ; count = 0
    mov ecx, count
    cmp ecx, 0
    jz  CM_Done

    mov esi, pA
    mov edi, pB

CM_Loop:
    cmp ecx, 0
    jz  CM_Done

    mov ebx, [esi]
    cmp ebx, [edi]
    jne CM_Skip
    inc eax

CM_Skip:
    add esi, 4
    add edi, 4
    dec ecx
    jmp CM_Loop

CM_Done:
    ret
CountMatches ENDP

9. CountNearMatches

두 배열 + 길이 + diff
|xi - yi| <= diff 이면 count++

CountNearMatches PROTO pA:PTR SDWORD, pB:PTR SDWORD, count:DWORD, diff:DWORD

CountNearMatches PROC USES esi edi ecx ebx edx, \
    pA:PTR SDWORD, pB:PTR SDWORD, count:DWORD, diff:DWORD

    xor eax, eax             ; count = 0
    mov ecx, count
    cmp ecx, 0
    jz  CNM_Done

    mov esi, pA
    mov edi, pB

CNM_Loop:
    cmp ecx, 0
    jz  CNM_Done

    mov ebx, [esi]           ; xi
    mov edx, [edi]           ; yi
    sub ebx, edx             ; xi - yi
    ; 절대값 구하기
    cmp ebx, 0
    jge CNM_Positive
    neg ebx

CNM_Positive:
    cmp ebx, diff
    jg  CNM_Skip
    inc eax

CNM_Skip:
    add esi, 4
    add edi, 4
    dec ecx
    jmp CNM_Loop

CNM_Done:
    ret
CountNearMatches ENDP

10. ShowParams

Caller(예: MySample)의 스택 파라미터 주소/값 출력
입력: 파라미터 개수(정수 1개)

핵심 아이디어는:

ShowParams 안에서 mov esi, [ebp] 하면 caller의 EBP

caller의 첫 번째 파라미터 주소는 [callerEBP+8]

그 주소부터 4바이트씩 올라가면서 찍기

ShowParams PROTO count:DWORD

.data
msgTitle BYTE "Stack parameters:",0
msgLine  BYTE 13,10,"Address ",0
msgEqual BYTE " = ",0

.code
MySample PROTO first:DWORD, second:DWORD, third:DWORD

main PROC
    INVOKE MySample, 1234h, 5000h, 6543h
    exit
main ENDP

MySample PROC first:DWORD, second:DWORD, third:DWORD
    paramCount = 3
    INVOKE ShowParams, paramCount
    ret
MySample ENDP

;-----------------------------------------
; ShowParams(count)
; caller의 스택 파라미터들을
;   주소, 값 순으로 출력
;-----------------------------------------
ShowParams PROC USES esi edi ecx eax, count:DWORD

    ; 제목
    INVOKE Crlf
    INVOKE WriteString, OFFSET msgTitle
    INVOKE Crlf

    mov ecx, count          ; 출력할 개수

    mov esi, [ebp]          ; caller의 EBP
    lea edi, [esi+8]        ; caller의 첫 번째 파라미터 주소

SP_Loop:
    cmp ecx, 0
    jz  SP_Done

    ; "Address " 출력
    INVOKE WriteString, OFFSET msgLine

    ; 주소 출력
    mov eax, edi
    INVOKE WriteHex          ; 주소

    INVOKE WriteString, OFFSET msgEqual

    ; 값 출력
    mov eax, [edi]
    INVOKE WriteHex

    INVOKE Crlf

    add edi, 4
    dec ecx
    jmp SP_Loop

SP_Done:
    ret
ShowParams ENDP


이렇게 하면 예시처럼:

Address 0012FF80 = 00001234
Address 0012FF84 = 00005000
Address 0012FF88 = 00006543
