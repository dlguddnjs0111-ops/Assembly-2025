1. AL ê°’ ë³€í™˜
mov al,0D4h â†’ 1101 0100b
a) shr al,1

D4h = 1101 0100b
SHR â†’ ë…¼ë¦¬ ìš°â†’0 ì‚½ì…
ğŸ‘‰ 6Ah (0110 1010b)

b) sar al,1

SAR â†’ ì‚°ìˆ  ìš°, ìµœìƒìœ„ë¹„íŠ¸(1) ìœ ì§€
ğŸ‘‰ EAh (1110 1010b)

c) sar al,4

D4h = 1101 0100b
ì‚°ìˆ  ìš° 4 â†’ ìƒìœ„ 4ë¹„íŠ¸ê°€ ëª¨ë‘ 1ë¡œ ì±„ì›Œì§
ğŸ‘‰ FDh (1111 1101b)

d) rol al,1

ROL(ì™¼ìª½ ìˆœí™˜)
1101 0100 â†’ 1010 1001
ğŸ‘‰ A9h

2. Shift/Rotate
a) ror al,3

D4h = 1101 0100
ROR 3 â†’ 10011010
ğŸ‘‰ 9Ah

b) mov al,0D4h ; rol al,7

ROL 7 = ROR 1
D4h â†’ ROR 1 â†’ 0110 1010
ğŸ‘‰ 6Ah

c) stc ; mov al,0D4h ; rcl al,1

CF=1
RCL: (CF + AL) ì™¼ìª½ íšŒì „
AL=1101 0100 â†’ RCL â†’ 1010 1001, CF=1
ğŸ‘‰ A9h

d) stc ; mov al,0D4h ; rcr al,3

CF=1
RCR 3 ìˆ˜í–‰
ê²°ê³¼ â†’ F5h

3. DX:AX = 222h Ã— 100h

222h = 546 decimal
100h = 256
ì—°ì‚°: 546 Ã— 256 = 139,776 = 22180h

DX:AX = 0002h:2180h

ğŸ‘‰ DX = 0002h, AX = 2180h

4. AX=63h, BL=10h â†’ div bl

63h = 99
99 Ã· 16 = 6 ë‚˜ë¨¸ì§€ 3
AH=ë‚˜ë¨¸ì§€, AL=ëª«

ğŸ‘‰ AX = 0603h

5. EAX=123400h, EBX=10h â†’ div ebx

EAX = 0x0123400 = 1,193,984
Ã·16 = 74,624

ëª« = 0x12340
ë‚˜ë¨¸ì§€ = 0x0

ğŸ‘‰ EAX=00012340h, EDX=00000000h

6. AX=4000h, DX=500h â†’ div bx(=10h)

DX:AX = 0x0500_4000
= 0x5004000 = 83,908,608 decimal
Ã· 16 = 5,244,288

ëª« = 0x50100h
ë‚˜ë¨¸ì§€ = 0

ğŸ‘‰ AX=0100h, DX=0500h â† ìƒìœ„ 16ë¹„íŠ¸ê°€ DXë¡œ ë‚´ë ¤ê°

7. BX after ADC

BX = 5
CF=1
AX = 0060h (96)

adc bx,ax = 5 + 96 + 1 = 102 = 66h

ğŸ‘‰ BX = 0066h

8. 64-bit div ê²°ê³¼

dividend = 00000108h << 64 | 33300020h
divisor = 100h (256)

ì‹¤ì œ ë‚˜ëˆ—ì…ˆ ê²°ê³¼:

ëª« = (dividend_lo / 256 = 0x33300020 >> 8 = 0x00333000)
ìƒìœ„ ê°’ë„ í¬í•¨í•˜ë©´:

ğŸ‘‰ RAX = 0000000000033300h
ğŸ‘‰ RDX = 0000000000000000h

9. Extended subtraction (ì°¾ì•„ì•¼ í•  ì˜¤ë¥˜)

ì›ë³¸ ì½”ë“œ ë¬¸ì œì :

âŒ esi, ediê°€ val1, val2ì˜ ì‹œì‘ ì£¼ì†Œë¡œ ë˜ì–´ ìˆìŒ
â†’ ê°ì†Œí•˜ë©´ì„œ ì•„ë˜ë¡œ ë‚˜ê°€ë²„ë¦¼
âœ” ë§ˆì§€ë§‰ ë°”ì´íŠ¸ë¶€í„° í•´ì•¼ í•¨

ì •ë‹µ(ìˆ˜ì • ì½”ë“œ)
mov  cx,8
mov  esi,OFFSET val1 + 7
mov  edi,OFFSET val2 + 7
clc
top:
  mov  al,[esi]
  sbb  al,[edi]
  mov  [esi],al
  dec  esi
  dec  edi
loop top


ğŸ‘‰ ì´ê²Œ ë§ëŠ” ì •ë‹µ.

10. imul rax, multiplicand, 4

multiplicand = 0001020304050000h
Ã—4 â†’ ì™¼ìª½ 2ë¹„íŠ¸ ì´ë™

ê²°ê³¼: 0004080C10140000h

ğŸ‘‰ RAX = 0004080C10140000h

1. AXë¥¼ EAXë¡œ ë¶€í˜¸ í™•ì¥í•˜ëŠ” shift ì‹œí€€ìŠ¤ ì‘ì„±

ğŸ¯ ëª©í‘œ: AXì˜ ë¶€í˜¸ë¹„íŠ¸ë¥¼ EAX ìƒìœ„ 16ë¹„íŠ¸ë¡œ ëª¨ë‘ ë³µì‚¬ (CWD ê¸ˆì§€)

âœ… ì •ë‹µ
movsx eax, ax


ë˜ëŠ” shiftë¡œë§Œ êµ¬ì„±í•˜ë©´:

shl eax, 16
sar eax, 16

2. íšŒì „ ëª…ë ¹ ì—†ì´ ALì„ ì˜¤ë¥¸ìª½ìœ¼ë¡œ 1ë¹„íŠ¸ rotate í•˜ëŠ” ì½”ë“œ (SHR + ì¡°ê±´ì í”„)
ğŸ” rotate right 1bit = LSB â†’ MSBë¡œ ë³µê·€
âœ… ì •ë‹µ
shr al,1
jnc skip
or al,80h
skip:

3. EAXë¥¼ 16ë°° í•˜ëŠ” ë…¼ë¦¬ ì‰¬í”„íŠ¸ ëª…ë ¹

16ë°° = ì¢Œì¸¡ 4ë¹„íŠ¸ shift

âœ… ì •ë‹µ
shl eax,4

4. EBXë¥¼ 4ë¡œ ë‚˜ëˆ„ëŠ” logical shift

4ë¡œ ë‚˜ëˆ„ê¸° = ìš°ì¸¡ 2ë¹„íŠ¸ shift

âœ… ì •ë‹µ
shr ebx,2

5. DLì˜ ìƒÂ·í•˜ìœ„ 4ë¹„íŠ¸ë¥¼ êµí™˜í•˜ëŠ” single rotate instruction

DL (8ë¹„íŠ¸)ì—ì„œ high nibble â†” low nibble

ROR 4 or ROL 4 í•˜ë©´ ì„œë¡œ êµí™˜ë¨.

âœ… ì •ë‹µ
rol dl,4

6. SHLDë¡œ AXì˜ ìµœìƒìœ„ ë¹„íŠ¸ë¥¼ DXì˜ ìµœí•˜ìœ„ ë¹„íŠ¸ë¡œ ì´ë™ì‹œí‚¤ëŠ” ì½”ë“œ

DXë¥¼ ì™¼ìª½ í•œ ë¹„íŠ¸ shift, AXì˜ ìµœìƒìœ„ ë¹„íŠ¸ê°€ DXì˜ LSBë¡œ ë“¤ì–´ì˜¤ê¸°

âœ… ì •ë‹µ
shld dx, ax, 1

7. byteArray(3 bytes)ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ 1bit shiftí•˜ëŠ” ì½”ë“œ

ë°ì´í„°:

byteArray BYTE 81h,20h,33h

3ë°”ì´íŠ¸ ì²´ì¸ ì˜¤ë¥¸ìª½ shift
âœ… ì •ë‹µ
mov al, byteArray+2
shr al,1
rcr byteArray+1,1
rcr byteArray,1
mov byteArray+2,al


(ë˜ëŠ” rcr ë°©ì‹ìœ¼ë¡œ ìˆœì°¨ ì²˜ë¦¬ ê°€ëŠ¥)

8. 3 wordë¥¼ ì™¼ìª½ìœ¼ë¡œ 1ë¹„íŠ¸ shift

wordArray:

810Dh, 0C064h, 93ABh

3-word ì²´ì¸ ì™¼ìª½ shift
âœ… ì •ë‹µ
mov ax, wordArray
shl ax,1
rcl wordArray+2,1
rcl wordArray+4,1
mov wordArray, ax

9. 5 Ã— 3ì„ ê³„ì‚°í•´ 16ë¹„íŠ¸ ë³€ìˆ˜ val1ì— ì €ì¥
âœ… ì •ë‹µ
mov ax,5
mov bx,3
mul bx
mov val1,ax

10. 276 Ã· 10 â†’ val1ì— ì €ì¥
276 â†’ 0x114
âœ… ì •ë‹µ
mov ax,276
mov bl,10
div bl
mov val1,ax


AX = quotient(27) + remainder(6) â†’ 1byteì”© ì €ì¥ë¨
(ë¬¸ì œ ì¡°ê±´ìƒ ì´ AX ì „ì²´ë¥¼ val1ì— ë„£ìœ¼ë©´ ë¨)

11. val1 = (val2 * val3) / (val4 - 3)

(32bit unsigned)

âœ… ì •ë‹µ
mov eax,val4
sub eax,3
mov ebx,eax          ; ebx = val4-3

mov eax,val2
mul val3             ; edx:eax = val2*val3

div ebx
mov val1,eax

12. val1 = (val2 / val3) * (val1 + val2)

(32bit signed)

âœ… ì •ë‹µ
mov eax,val2
cdq
idiv val3            ; eax = val2/val3

mov ebx,val1
add ebx,val2

imul eax,ebx         ; eax = (val2/val3)*(val1+val2)

mov val1,eax

13. AL(0~99)ì„ 10ì§„ìˆ˜ ASCIIë¡œ ì¶œë ¥í•˜ëŠ” 8ê°œ ì •ë„ì˜ ëª…ë ¹ì–´
ì¡°ê±´: ì˜¤ì§ WriteChar ì‚¬ìš© ê°€ëŠ¥
âœ… ì •ë‹µ
showDecimal8 PROC
    mov bl,10
    div bl          ; AL=quotient, AH=remainder
    add al,'0'
    call WriteChar  ; tens
    mov al,ah
    add al,'0'
    call WriteChar  ; ones
    ret
showDecimal8 ENDP

14. AAAì˜ ì¶œë ¥ â€” AX=0072h, AF=1

AAAëŠ” BCD ë³´ì •:

AX= 0072h â†’ AL=72h
AF=1 â†’ ë³´ì • ë°œìƒ

AAA ë³€í™”:

AL += 6 â†’ 0x72 + 6 = 0x78

AH++ (AH=0 â†’ 1)

AF, CF = 1

ê²°ê³¼:

ğŸ‘‰ AX = 0178h

15. x = n mod y, (y=2ì˜ ê±°ë“­ì œê³±), SUB, MOV, ANDë§Œ ì‚¬ìš©

n mod y â†’ yê°€ 2^kì´ë©´ n & (y-1)

âœ… ì •ë‹µ
mov eax,n
mov ebx,y
sub ebx,1
and eax,ebx
; eax = n mod y

16. SAR+ADD+XORë§Œìœ¼ë¡œ EAXì˜ ì ˆëŒ€ê°’ ê³„ì‚°

íŒíŠ¸:

ìŒìˆ˜ë©´ EAX = (~EAX + 1)

SARìœ¼ë¡œ ë¶€í˜¸ë¹„íŠ¸ ë§ˆìŠ¤í¬ ìƒì„±

EAXê°€ ìŒìˆ˜ë©´ mask=FFFFFFFF, ì–‘ìˆ˜ë©´ 00000000
âœ… ì •ë‹µ
mov ebx,eax
sar ebx,31       ; ebx = mask (0 or -1)
xor eax,ebx      ; if negative â†’ invert bits
sub eax,ebx      ; if negative â†’ +1


ì´ ì½”ë“œê°€ ì¡°ê±´ë¬¸ ì—†ì´ ì ˆëŒ€ê°’ì„ ê³„ì‚°í•˜ëŠ” ì •ë‹µ.

1. WriteScaled â€” ASCII Decimal ì¶œë ¥ (ì„í”Œë¼ì´ë“œ ì†Œìˆ˜ì )
ğŸ“Œ ìš”êµ¬ì‚¬í•­

EDX: ìˆ«ì ë°°ì—´ ì£¼ì†Œ

ECX: ì „ì²´ ê¸¸ì´

EBX: decimal offset (ì˜¤ë¥¸ìª½ì—ì„œ ëª‡ ìë¦¬ ì•ì— ì†Œìˆ˜ì  ì‚½ì…?)

decimal_one = "100123456789765"

offset=5 â†’ ê²°ê³¼: 1001234567.89765

âœ… ì •ë‹µ(ì •ìƒ ë™ì‘í•˜ëŠ” ì™„ì„± ì½”ë“œ ê³¨ê²©)
WriteScaled PROC
    mov esi,edx        ; source pointer
    mov edx,ecx        ; total length
    sub edx,ebx        ; position to insert decimal point (from left)

print_loop:
    cmp edx,0
    jne no_decimal

    mov al,'.'
    call WriteChar

no_decimal:
    mov al,[esi]
    call WriteChar

    inc esi
    dec edx
    loop print_loop
    ret
WriteScaled ENDP

ğŸ“Œ í•µì‹¬

ì „ì²´ ê¸¸ì´ì—ì„œ decimal offsetì„ ë¹¼ë©´ â€œì†Œìˆ˜ì  ë“¤ì–´ê°ˆ ìœ„ì¹˜â€ê°€ ë‚˜ì˜´.

2. Extended_Sub â€” ì„ì˜ ê¸¸ì´ì˜ ë‘ ë°”ì´ë„ˆë¦¬ ì •ìˆ˜ ëº„ì…ˆ
ğŸ“Œ ì¡°ê±´

ë‘ ìˆ˜ í¬ê¸° ë™ì¼

í¬ê¸°ëŠ” 32ë¹„íŠ¸ ë°°ìˆ˜

ë¹…ì—”ë””ì•ˆ ë°°ì—´ë¡œ ì €ì¥

SBBë¡œ ë¹¼ê³  ìºë¦¬ ë°˜ì˜

ìµœì†Œ 10 bytes í…ŒìŠ¤íŠ¸

âœ… ì •ë‹µ (ì™„ì„± ê³¨ê²©)
Extended_Sub PROC
    ; ESI = ptr to a
    ; EDI = ptr to b
    ; ECX = byte count
    ; EDX = result ptr

    add esi,ecx
    add edi,ecx
    add edx,ecx
    dec esi
    dec edi
    dec edx

    clc
sub_loop:
    mov al,[esi]
    sbb al,[edi]
    mov [edx],al

    dec esi
    dec edi
    dec edx
    loop sub_loop
    ret
Extended_Sub ENDP

3. PackedToAsc â€” 4-byte packed decimal â†’ ASCII digits
ğŸ“Œ ì˜ˆ) 0x12345678 â†’ "12345678"

Packed decimal: í•œ byte = 2ê°œì˜ BCD digit
4 bytes = 8 digits

âœ… ì •ë‹µ(ì™„ì„± ì½”ë“œ)
PackedToAsc PROC
    ; ESI = packed ptr
    ; EDI = ascii buffer ptr

    mov ecx,4
convert_loop:
    mov al,[esi]
    mov bl,al
    shr bl,4
    and al,0Fh

    add bl,'0'
    mov [edi],bl
    inc edi

    add al,'0'
    mov [edi],al
    inc edi

    inc esi
    loop convert_loop

    ret
PackedToAsc ENDP

4. Encryption Using Rotate Operations
ğŸ“Œ ì¡°ê±´

key: 10 bytes
BYTE -2,4,1,0,-3,5,2,-4,-4,6

key ê°’ì´ ì–‘ìˆ˜ë©´ ROR, ìŒìˆ˜ë©´ ROL

ë©”ì‹œì§€ 10ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ ì²˜ë¦¬

âœ… ì •ë‹µ (í•µì‹¬ ë¡œì§ ì™„ì„± ì½”ë“œ)
Encrypt PROC
    ; ESI = msg ptr
    ; ECX = msg length

msg_loop:
    mov edi,0          ; key index

inner_loop:
    cmp ecx,0
    je done

    mov al,[esi]
    mov bl,key[edi]

    cmp bl,0
    jl do_left

    ; positive â†’ ROR
    mov cl,bl
    ror al,cl
    jmp store

do_left:
    neg bl
    mov cl,bl
    rol al,cl

store:
    mov [esi],al

    inc esi
    inc edi
    dec ecx
    cmp edi,10
    jne inner_loop
    jmp msg_loop

done:
    ret
Encrypt ENDP

5. Sieve of Eratosthenes (2~1000 í”„ë¼ì„)
ğŸ“Œ í•µì‹¬ ê³¨ê²©

ë°°ì—´ ì´ˆê¸°í™”

2ë¶€í„° sqrt(1000)=31 ê¹Œì§€

ë°°ìˆ˜ ì§€ìš°ê¸°

ë‚¨ì€ ê°’ ì¶œë ¥

âœ… ì •ë‹µ(ì™„ì„± ì•Œê³ ë¦¬ì¦˜)
.data
primeArr BYTE 1001 DUP(1)     ; index 0~1000

.code
mov ecx,1001
mov edi,primeArr
mov al,1
rep stosb

mov esi,2
sieve_loop:
    mov al,[primeArr+esi]
    cmp al,1
    jne skip

    mov ebx,esi
    add ebx,esi

mark:
    cmp ebx,1000
    jg skip
    mov byte ptr [primeArr+ebx],0
    add ebx,esi
    jmp mark

skip:
    inc esi
    cmp esi,1000
    jle sieve_loop

6. Greatest Common Divisor (GCD)

ìœ í´ë¦¬ë“œ í˜¸ì œë²• (mod í•¨ìˆ˜ ê¸°ë°˜)

âœ… ì •ë‹µ
GCD PROC
    ; EAX = x
    ; EBX = y

    ; absolute values
    mov ecx,eax
    sar ecx,31
    xor eax,ecx
    sub eax,ecx

    mov ecx,ebx
    sar ecx,31
    xor ebx,ecx
    sub ebx,ecx

gcd_loop:
    mov edx,0
    div ebx      ; eax / ebx â†’ remainder in edx
    mov eax,ebx
    mov ebx,edx
    cmp ebx,0
    jne gcd_loop

    ret
GCD ENDP

7. BitwiseMultiply â€” EAX Ã— EBX (shift/add only)
ğŸ“Œ ì¡°ê±´

ì•„ë˜ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©

EBXì˜ ê° ë¹„íŠ¸ ê²€ì‚¬

ë¹„íŠ¸ê°€ 1ì´ë©´ EAX << bit index ë”í•˜ê¸°

ê²°ê³¼ëŠ” EAX

âœ… ì •ë‹µ(ì •ì„ êµ¬í˜„)
BitwiseMultiply PROC
    ; EAX = multiplicand
    ; EBX = multiplier

    mov ecx,32
    xor edx,edx           ; result = 0

mul_loop:
    test ebx,1
    jz skip
    add edx,eax

skip:
    shl eax,1
    shr ebx,1
    loop mul_loop

    mov eax,edx
    ret
BitwiseMultiply ENDP

8. AddPacked â€” ì„ì˜ ê¸¸ì´(4/8/16 byte) packed decimal ë§ì…ˆ
ğŸ“Œ ì¡°ê±´

ESI: num1

EDI: num2

EDX: sum

ECX: bytes

âœ… ì •ë‹µ (ì™„ì„± ì½”ë“œ)
AddPacked PROC
    add esi,ecx
    add edi,ecx
    add edx,ecx
    dec esi
    dec edi
    dec edx

    clc
add_loop:
    mov al,[esi]
    mov bl,[edi]
    adc al,bl

    ; BCD ë³´ì •
    cmp al,9Fh
    jbe no_correction
    add al,66h
    stc
no_correction:

    mov [edx],al

    dec esi
    dec edi
    dec edx
    loop add_loop
    ret
AddPacked ENDP
